// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: leaderserver.proto

package leaderserver

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// LeaderServerClient is the client API for LeaderServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LeaderServerClient interface {
	GetLeader(ctx context.Context, in *GetLeaderRequest, opts ...grpc.CallOption) (*GetLeaderReply, error)
	GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoReply, error)
	GetFileOK(ctx context.Context, in *GetFileOKRequest, opts ...grpc.CallOption) (*GetFileOKReply, error)
	PutBlockInfo(ctx context.Context, in *PutBlockInfoRequest, opts ...grpc.CallOption) (*PutBlockInfoReply, error)
	PutFileOK(ctx context.Context, in *PutFileOKRequest, opts ...grpc.CallOption) (*PutFileOKReply, error)
	DelFile(ctx context.Context, in *DelFileRequest, opts ...grpc.CallOption) (*DelFileReply, error)
	GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataReply, error)
	SetLeader(ctx context.Context, in *SetLeaderRequest, opts ...grpc.CallOption) (*SetLeaderReply, error)
	AcquireReadLock(ctx context.Context, in *AcquireLockRequest, opts ...grpc.CallOption) (*AcquireLockReply, error)
	ReleaseReadLock(ctx context.Context, in *ReleaseLockRequest, opts ...grpc.CallOption) (*ReleaseLockReply, error)
	AcquireWriteLock(ctx context.Context, in *AcquireLockRequest, opts ...grpc.CallOption) (*AcquireLockReply, error)
	ReleaseWriteLock(ctx context.Context, in *ReleaseLockRequest, opts ...grpc.CallOption) (*ReleaseLockReply, error)
}

type leaderServerClient struct {
	cc grpc.ClientConnInterface
}

func NewLeaderServerClient(cc grpc.ClientConnInterface) LeaderServerClient {
	return &leaderServerClient{cc}
}

func (c *leaderServerClient) GetLeader(ctx context.Context, in *GetLeaderRequest, opts ...grpc.CallOption) (*GetLeaderReply, error) {
	out := new(GetLeaderReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/GetLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) GetBlockInfo(ctx context.Context, in *GetBlockInfoRequest, opts ...grpc.CallOption) (*GetBlockInfoReply, error) {
	out := new(GetBlockInfoReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/GetBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) GetFileOK(ctx context.Context, in *GetFileOKRequest, opts ...grpc.CallOption) (*GetFileOKReply, error) {
	out := new(GetFileOKReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/GetFileOK", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) PutBlockInfo(ctx context.Context, in *PutBlockInfoRequest, opts ...grpc.CallOption) (*PutBlockInfoReply, error) {
	out := new(PutBlockInfoReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/PutBlockInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) PutFileOK(ctx context.Context, in *PutFileOKRequest, opts ...grpc.CallOption) (*PutFileOKReply, error) {
	out := new(PutFileOKReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/PutFileOK", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) DelFile(ctx context.Context, in *DelFileRequest, opts ...grpc.CallOption) (*DelFileReply, error) {
	out := new(DelFileReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/DelFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) GetMetadata(ctx context.Context, in *GetMetadataRequest, opts ...grpc.CallOption) (*GetMetadataReply, error) {
	out := new(GetMetadataReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/GetMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) SetLeader(ctx context.Context, in *SetLeaderRequest, opts ...grpc.CallOption) (*SetLeaderReply, error) {
	out := new(SetLeaderReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/SetLeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) AcquireReadLock(ctx context.Context, in *AcquireLockRequest, opts ...grpc.CallOption) (*AcquireLockReply, error) {
	out := new(AcquireLockReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/AcquireReadLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) ReleaseReadLock(ctx context.Context, in *ReleaseLockRequest, opts ...grpc.CallOption) (*ReleaseLockReply, error) {
	out := new(ReleaseLockReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/ReleaseReadLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) AcquireWriteLock(ctx context.Context, in *AcquireLockRequest, opts ...grpc.CallOption) (*AcquireLockReply, error) {
	out := new(AcquireLockReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/AcquireWriteLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leaderServerClient) ReleaseWriteLock(ctx context.Context, in *ReleaseLockRequest, opts ...grpc.CallOption) (*ReleaseLockReply, error) {
	out := new(ReleaseLockReply)
	err := c.cc.Invoke(ctx, "/leaderserver.LeaderServer/ReleaseWriteLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LeaderServerServer is the server API for LeaderServer service.
// All implementations must embed UnimplementedLeaderServerServer
// for forward compatibility
type LeaderServerServer interface {
	GetLeader(context.Context, *GetLeaderRequest) (*GetLeaderReply, error)
	GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoReply, error)
	GetFileOK(context.Context, *GetFileOKRequest) (*GetFileOKReply, error)
	PutBlockInfo(context.Context, *PutBlockInfoRequest) (*PutBlockInfoReply, error)
	PutFileOK(context.Context, *PutFileOKRequest) (*PutFileOKReply, error)
	DelFile(context.Context, *DelFileRequest) (*DelFileReply, error)
	GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataReply, error)
	SetLeader(context.Context, *SetLeaderRequest) (*SetLeaderReply, error)
	AcquireReadLock(context.Context, *AcquireLockRequest) (*AcquireLockReply, error)
	ReleaseReadLock(context.Context, *ReleaseLockRequest) (*ReleaseLockReply, error)
	AcquireWriteLock(context.Context, *AcquireLockRequest) (*AcquireLockReply, error)
	ReleaseWriteLock(context.Context, *ReleaseLockRequest) (*ReleaseLockReply, error)
	mustEmbedUnimplementedLeaderServerServer()
}

// UnimplementedLeaderServerServer must be embedded to have forward compatible implementations.
type UnimplementedLeaderServerServer struct {
}

func (UnimplementedLeaderServerServer) GetLeader(context.Context, *GetLeaderRequest) (*GetLeaderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLeader not implemented")
}
func (UnimplementedLeaderServerServer) GetBlockInfo(context.Context, *GetBlockInfoRequest) (*GetBlockInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockInfo not implemented")
}
func (UnimplementedLeaderServerServer) GetFileOK(context.Context, *GetFileOKRequest) (*GetFileOKReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileOK not implemented")
}
func (UnimplementedLeaderServerServer) PutBlockInfo(context.Context, *PutBlockInfoRequest) (*PutBlockInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutBlockInfo not implemented")
}
func (UnimplementedLeaderServerServer) PutFileOK(context.Context, *PutFileOKRequest) (*PutFileOKReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutFileOK not implemented")
}
func (UnimplementedLeaderServerServer) DelFile(context.Context, *DelFileRequest) (*DelFileReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelFile not implemented")
}
func (UnimplementedLeaderServerServer) GetMetadata(context.Context, *GetMetadataRequest) (*GetMetadataReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadata not implemented")
}
func (UnimplementedLeaderServerServer) SetLeader(context.Context, *SetLeaderRequest) (*SetLeaderReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLeader not implemented")
}
func (UnimplementedLeaderServerServer) AcquireReadLock(context.Context, *AcquireLockRequest) (*AcquireLockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcquireReadLock not implemented")
}
func (UnimplementedLeaderServerServer) ReleaseReadLock(context.Context, *ReleaseLockRequest) (*ReleaseLockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseReadLock not implemented")
}
func (UnimplementedLeaderServerServer) AcquireWriteLock(context.Context, *AcquireLockRequest) (*AcquireLockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcquireWriteLock not implemented")
}
func (UnimplementedLeaderServerServer) ReleaseWriteLock(context.Context, *ReleaseLockRequest) (*ReleaseLockReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseWriteLock not implemented")
}
func (UnimplementedLeaderServerServer) mustEmbedUnimplementedLeaderServerServer() {}

// UnsafeLeaderServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LeaderServerServer will
// result in compilation errors.
type UnsafeLeaderServerServer interface {
	mustEmbedUnimplementedLeaderServerServer()
}

func RegisterLeaderServerServer(s grpc.ServiceRegistrar, srv LeaderServerServer) {
	s.RegisterService(&LeaderServer_ServiceDesc, srv)
}

func _LeaderServer_GetLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).GetLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/GetLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).GetLeader(ctx, req.(*GetLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_GetBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).GetBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/GetBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).GetBlockInfo(ctx, req.(*GetBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_GetFileOK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileOKRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).GetFileOK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/GetFileOK",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).GetFileOK(ctx, req.(*GetFileOKRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_PutBlockInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutBlockInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).PutBlockInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/PutBlockInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).PutBlockInfo(ctx, req.(*PutBlockInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_PutFileOK_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutFileOKRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).PutFileOK(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/PutFileOK",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).PutFileOK(ctx, req.(*PutFileOKRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_DelFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).DelFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/DelFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).DelFile(ctx, req.(*DelFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_GetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).GetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/GetMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).GetMetadata(ctx, req.(*GetMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_SetLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).SetLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/SetLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).SetLeader(ctx, req.(*SetLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_AcquireReadLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcquireLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).AcquireReadLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/AcquireReadLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).AcquireReadLock(ctx, req.(*AcquireLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_ReleaseReadLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).ReleaseReadLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/ReleaseReadLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).ReleaseReadLock(ctx, req.(*ReleaseLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_AcquireWriteLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcquireLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).AcquireWriteLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/AcquireWriteLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).AcquireWriteLock(ctx, req.(*AcquireLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeaderServer_ReleaseWriteLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeaderServerServer).ReleaseWriteLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/leaderserver.LeaderServer/ReleaseWriteLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeaderServerServer).ReleaseWriteLock(ctx, req.(*ReleaseLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LeaderServer_ServiceDesc is the grpc.ServiceDesc for LeaderServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LeaderServer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "leaderserver.LeaderServer",
	HandlerType: (*LeaderServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLeader",
			Handler:    _LeaderServer_GetLeader_Handler,
		},
		{
			MethodName: "GetBlockInfo",
			Handler:    _LeaderServer_GetBlockInfo_Handler,
		},
		{
			MethodName: "GetFileOK",
			Handler:    _LeaderServer_GetFileOK_Handler,
		},
		{
			MethodName: "PutBlockInfo",
			Handler:    _LeaderServer_PutBlockInfo_Handler,
		},
		{
			MethodName: "PutFileOK",
			Handler:    _LeaderServer_PutFileOK_Handler,
		},
		{
			MethodName: "DelFile",
			Handler:    _LeaderServer_DelFile_Handler,
		},
		{
			MethodName: "GetMetadata",
			Handler:    _LeaderServer_GetMetadata_Handler,
		},
		{
			MethodName: "SetLeader",
			Handler:    _LeaderServer_SetLeader_Handler,
		},
		{
			MethodName: "AcquireReadLock",
			Handler:    _LeaderServer_AcquireReadLock_Handler,
		},
		{
			MethodName: "ReleaseReadLock",
			Handler:    _LeaderServer_ReleaseReadLock_Handler,
		},
		{
			MethodName: "AcquireWriteLock",
			Handler:    _LeaderServer_AcquireWriteLock_Handler,
		},
		{
			MethodName: "ReleaseWriteLock",
			Handler:    _LeaderServer_ReleaseWriteLock_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "leaderserver.proto",
}
